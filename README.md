# enigma

In this README file I will copy/paste each section of the "Meets Expections" rubric then assess myself on that section.

Enigma Class with encrypt and decrypt methods successfully implemented. 
Encrypt/decrypt command line interfaces successfully implemented.
I built the classes and runner files according to the project specs, and they are fully functional.

Project is broken into logical components that are appropriately encapsulated. 
No classes are unreasonably small or large, or contain knowledge/information/behavior that they shouldnâ€™t know about. 
Student can articulate the single responsibilities of the various components.
Outside of the runner files, I managed to fit all necessary code outside of testing into the Enigma class, which was only 120 lines long.
I used many helper methods to DRY my code and ensure that each method has one responsibility. 

Code is mostly properly indented, spaced, and lines are not excessively long. Class, method, variable, and file names follow convention. 
Some enumerables/data structures chosen are the most efficient tool for a given job, 
and students can speak as to why those enumerables/data structures were chosen. 
At least one hash is implemented in a way that makes logical sense.
All my code is properly indented, and uses whitespace to increase readability. All names follow convention, and I use argueablly best-choice
enumerables such as .any?, .map, and .each when I could think of no better option. Hashes were my best friend in this project, as I used over five hashes 
to help store data.

Every method is tested at both the unit and integration level, and completely verify expected behavior 
(i.e., if a single method does 3 things, all 3 things are explicitly tested). Obvious edge cases are addressed. 
git history demonstrates students are writing tests before implementation code. Test coverage metrics show coverage at 99% or greater.
Every method is tested thoroughly (the runner files were not tested at all as the project did not require it). 
Each possible case, as including default cases, is tested and simplecov shows 100% coverage. My commit history nearly always follows the pattern 
Test:... Feat:... Test:... etc...

Minimum 30 commits and 3 pull requests. More than half of your pull requests include related and logical chunks of functionality, 
and are named and documented to clearly communicate the purpose of the pull request. No more than 3 commits include multiple pieces of functionality.
I did not meet the minimum commit requirements (I am somewhere around twenty-five), but I do not see this as a problem. My coding process went over
very smoothly so I did not have alot of commits for debugging. Each of my pull requests is seperated by functionality, and only one commit has multiple
pieces of functionality (I got carried away building my runner files while learning about files from Mike's video, so they ended up on one commit).
